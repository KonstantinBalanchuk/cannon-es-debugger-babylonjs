<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>cannon-es-debugger</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Monospace;
      }

      canvas {
        outline: none;
        width: 100vw;
        height: 100vh;
      }

      .page-title {
        position: fixed;
        top: 0.75rem;
        left: 0;
        right: 0;
        text-align: center;
        color: white;
      }
      .page-title span {
        color: #99ff4e;
      }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
  </head>
  <body>
    <div class="page-title">Press the <span>d</span> key to toggle the debugger</div>
    <canvas id="renderCanvas" touch-action="none"></canvas>

    <!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

    <script type="importmap">
      {
        "imports": {
          "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
          "cannon-es-debugger": "./dist/cannon-es-debugger.js"
        }
      }
    </script>
    <script type="module">
      import * as CANNON from 'cannon-es'
      import CannonDebugger from 'cannon-es-debugger'

      window.CANNON = CANNON

      const canvas = document.getElementById('renderCanvas') // Get the canvas element
      const engine = new BABYLON.Engine(canvas, true) // Generate the BABYLON 3D engine

      // // three.js variables
      let camera, light, shadowGenerator
      let material

      // // cannon.js variables
      let world
      const timeStep = 1 / 60
      let lastCallTime
      let cannonDebugger

      const carChassisSize = {
        width: 4,
        height: 0.5,
        depth: 2,
      }
      const carWheelSize = 0.5

      // // To be kept in sync
      const meshes = []
      const bodies = []

      const scene = await initBabylonJS()
      initCannon()
      initCannonDebugger()

      addPlane()
      addSphere({ mass: 1, position: { x: -0.5, y: 4, z: -1 }, radius: 1 })
      addSphere({ mass: 1, position: { x: -0.5, y: 8, z: -1 }, radius: 1 })

      const vehicle = addVehicle({
        position: {
          x: 10,
          y: 6,
          z: 0,
        },
      })

      setTimeout(() => {
        addBox({ width: 1, height: 1, depth: 1, position: { x: 2, y: 3, z: 0.5 }, mass: 1 })
      }, 500)

      if (vehicle) {
        document.addEventListener('keydown', (event) => {
          const maxSteerVal = Math.PI / 8
          const maxForce = 10

          switch (event.key) {
            case 'w':
            case 'ArrowUp':
              vehicle.setWheelForce(maxForce, 2)
              vehicle.setWheelForce(maxForce, 3)
              break

            case 's':
            case 'ArrowDown':
              vehicle.setWheelForce(-maxForce / 2, 2)
              vehicle.setWheelForce(-maxForce / 2, 3)
              break

            case 'a':
            case 'ArrowLeft':
              vehicle.setSteeringValue(maxSteerVal, 0)
              vehicle.setSteeringValue(maxSteerVal, 1)
              break

            case 'd':
            case 'ArrowRight':
              vehicle.setSteeringValue(-maxSteerVal, 0)
              vehicle.setSteeringValue(-maxSteerVal, 1)
              break
          }
        })

        // reset car force to zero when key is released
        document.addEventListener('keyup', (event) => {
          switch (event.key) {
            case 'w':
            case 'ArrowUp':
              vehicle.setWheelForce(0, 2)
              vehicle.setWheelForce(0, 3)
              break

            case 's':
            case 'ArrowDown':
              vehicle.setWheelForce(0, 2)
              vehicle.setWheelForce(0, 3)
              break

            case 'a':
            case 'ArrowLeft':
              vehicle.setSteeringValue(0, 0)
              vehicle.setSteeringValue(0, 1)
              break

            case 'd':
            case 'ArrowRight':
              vehicle.setSteeringValue(0, 0)
              vehicle.setSteeringValue(0, 1)
              break
          }
        })
      }

      addCylinder({ position: { x: -4, y: 2, z: -3.5 } })
      // addTrimesh()
      // addHeightfield()

      // animate()

      async function initBabylonJS() {
        // // Scene
        const scene = new BABYLON.Scene(engine)
        // Camera
        camera = new BABYLON.ArcRotateCamera('camera', -Math.PI / 2, Math.PI / 2.5, 15, new BABYLON.Vector3(0, 0, 0))
        camera.attachControl(canvas, true)
        const hemilight = new BABYLON.HemisphericLight('hemiLight', new BABYLON.Vector3(-1, 1, 0), scene)

        light = new BABYLON.DirectionalLight('dir01', new BABYLON.Vector3(2, -8, 2), scene)
        light.intensity = 0.4

        // Shadow generator
        shadowGenerator = new BABYLON.ShadowGenerator(1024, light)

        window.addEventListener('resize', onWindowResize)

        return scene
      }

      function onWindowResize() {
        engine.resize()
      }

      function initCannon() {
        // Setup world
        world = new CANNON.World()
        world.gravity.set(0, -9.81, 0)
      }

      function initCannonDebugger() {
        cannonDebugger = new CannonDebugger(scene, world, {
          onInit(body, mesh) {
            // Toggle visibiliy on "d" press
            document.addEventListener('keydown', (event) => {
              if (event.key === 'c') {
                mesh.isVisible = !mesh.isVisible
              }
            })
          },
        })
      }

      function updateMeshPositions() {
        for (let i = 0; i < meshes.length; i++) {
          const mesh = meshes[i]
          const { position, quaternion } = bodies[i]
          mesh.position.set(position.x, position.y, position.z)
          if (mesh.rotationQuaternion) {
            mesh.rotationQuaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w)
          }
        }
      }

      function addPlane() {
        // Physics
        const shape = new CANNON.Plane()
        const body = new CANNON.Body({ mass: 0 })
        body.addShape(shape)
        body.quaternion.setFromEuler(-Math.PI / 2, 0, 0)
        world.addBody(body)
        bodies.push(body)

        // Graphics
        const plane = BABYLON.MeshBuilder.CreatePlane('plane', { width: 10, height: 10 }, scene)
        plane.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0)
        plane.receiveShadows = true
        meshes.push(plane)
      }

      function addBox({ width, height, depth, position, mass }) {
        const size = 1

        // Physics
        const halfExtents = new CANNON.Vec3(width * 0.5, height * 0.5, depth * 0.5)
        const shape = new CANNON.Box(halfExtents)
        const body = new CANNON.Body({ mass })
        body.addShape(shape)
        body.position.set(position.x, position.y, position.z)
        world.addBody(body)
        bodies.push(body)

        // Graphics
        const box = BABYLON.MeshBuilder.CreateBox('box', { width, height, depth })
        box.rotationQuaternion = box.rotationQuaternion || new BABYLON.Quaternion()
        shadowGenerator.addShadowCaster(box, true)
        box.receiveShadow = true
        meshes.push(box)

        return body
      }

      function addSphere({ mass, wheelMaterial = undefined, position, radius }) {
        // Physics
        const body = new CANNON.Body({ mass, position, wheelMaterial })
        const shape = new CANNON.Sphere(radius)
        body.addShape(shape)
        body.position.set(position.x, position.y, position.z)
        world.addBody(body)
        bodies.push(body)

        // Graphics
        const sphere = BABYLON.MeshBuilder.CreateSphere('sphere', { radius })
        sphere.scalingDeterminant = radius * 2
        sphere.rotationQuaternion = sphere.rotationQuaternion || new BABYLON.Quaternion()
        shadowGenerator.addShadowCaster(sphere, true)
        sphere.receiveShadow = true
        meshes.push(sphere)

        return body
      }

      function addCylinder({
        height = 1,
        position,
        radius = 1,
        radiusTop = 1,
        radiusBottom = 1,
        mass = 1,
        numSegments = 8,
      }) {
        // Physics
        const body = new CANNON.Body({ mass })
        const shape = new CANNON.Cylinder(radiusTop, radiusBottom, height, numSegments)
        body.addShape(shape)
        body.position.set(position.x, position.y, position.z)
        world.addBody(body)
        bodies.push(body)

        // Graphics
        const cylinder = BABYLON.MeshBuilder.CreateCylinder(
          'cylinder',
          { diameterTop: radiusTop * 2, diameterBottom: radiusBottom * 2, height },
          scene
        )
        cylinder.rotationQuaternion = cylinder.rotationQuaternion || new BABYLON.Quaternion()
        shadowGenerator.addShadowCaster(cylinder, true)
        cylinder.receiveShadows = true
        meshes.push(cylinder)

        return body
      }

      // function addTrimesh() {
      //   const radius = 1
      //   const tube = 0.3
      //   const radialSegments = 16

      //   // Physics
      //   const body = new CANNON.Body({ mass })
      //   const shape = CANNON.Trimesh.createTorus(radius, tube, radialSegments, 16)
      //   body.addShape(shape)
      //   body.position.set(-3, 2, -1)
      //   body.quaternion.setFromEuler(Math.PI * 0.1, 0, 0)
      //   world.addBody(body)
      //   bodies.push(body)

      //   // Graphics
      //   const geometry = new THREE.TorusGeometry(radius, tube, radialSegments, 100)
      //   const mesh = new THREE.Mesh(geometry, material)
      //   // position and quaternion of the mesh are set by updateMeshPositions...
      //   mesh.castShadow = true
      //   mesh.receiveShadow = true
      //   scene.add(mesh)
      //   meshes.push(mesh)
      // }

      // function addHeightfield() {
      //   const sizeX = 20 // number of vertices in the X axis
      //   const sizeY = 20 // number of vertices in the Y axis
      //   const elementSize = 0.3 // cell width
      //   const depth = 0.6

      //   // Physics
      //   const body = new CANNON.Body({ mass: 0 })
      //   const matrix = []
      //   for (let i = 0; i < sizeX; i++) {
      //     matrix.push([])
      //     for (let j = 0; j < sizeY; j++) {
      //       const height = Math.cos((i / (sizeX - 1)) * Math.PI * 2) * Math.cos((j / (sizeY - 1)) * Math.PI * 2) * depth
      //       matrix[i].push(height)
      //     }
      //   }
      //   const shape = new CANNON.Heightfield(matrix, { elementSize })
      //   body.addShape(shape, new CANNON.Vec3((-(sizeX - 1) / 2) * elementSize, (-(sizeY - 1) / 2) * elementSize, 0))
      //   body.position.set(0, depth, -6)
      //   body.quaternion.setFromEuler(-Math.PI / 2, 0, 0)
      //   world.addBody(body)
      //   bodies.push(body)

      //   // Graphics
      //   const geometry = new THREE.PlaneGeometry(
      //     (sizeX - 1) * elementSize,
      //     (sizeY - 1) * elementSize,
      //     sizeX - 1,
      //     sizeY - 1
      //   )
      //   for (let i = 0; i < sizeX; i++) {
      //     for (let j = 0; j < sizeY; j++) {
      //       const height = Math.cos((i / (sizeX - 1)) * Math.PI * 2) * Math.cos((j / (sizeY - 1)) * Math.PI * 2) * depth

      //       geometry.attributes.position.setZ(i * sizeX + j, height)
      //     }
      //   }
      //   geometry.computeBoundingSphere()
      //   geometry.computeVertexNormals()
      //   const mesh = new THREE.Mesh(geometry, material)
      //   // position and quaternion of the mesh are set by updateMeshPositions...
      //   mesh.castShadow = true
      //   mesh.receiveShadow = true
      //   scene.add(mesh)
      //   meshes.push(mesh)
      // }

      function addVehicle({ position }) {
        const carBody = addBox({
          mass: 5,
          position,
          width: carChassisSize.width,
          height: carChassisSize.height,
          depth: carChassisSize.depth,
        })

        // because of some reason it looks like it's upside down
        carBody.quaternion.setFromEuler(-Math.PI, 0, 0)

        const vehicle = new CANNON.RigidVehicle({
          chassisBody: carBody,
        })

        // wheels
        const wheelMass = 1
        const axisWidth = carChassisSize.width
        const wheelMaterial = new CANNON.Material('wheel')
        const down = new CANNON.Vec3(0, -1, 0)

        const wheelBody1 = addSphere({
          mass: wheelMass,
          wheelMaterial,
          position: { x: 0, y: 0, z: 0 },
          radius: carWheelSize,
        })
        wheelBody1.angularDamping = 0.4
        vehicle.addWheel({
          body: wheelBody1,
          position: new CANNON.Vec3(-1, 0.3, axisWidth / 6),
          axis: new CANNON.Vec3(0, 0, 1),
          direction: down,
        })

        const wheelBody2 = addSphere({
          mass: wheelMass,
          wheelMaterial,
          position: { x: 0, y: 0, z: 0 },
          radius: carWheelSize,
        })
        wheelBody2.angularDamping = 0.4
        vehicle.addWheel({
          body: wheelBody2,
          position: new CANNON.Vec3(-1, 0.3, -axisWidth / 6),
          axis: new CANNON.Vec3(0, 0, 1),
          direction: down,
        })

        const wheelBody3 = addSphere({
          mass: wheelMass,
          wheelMaterial,
          position: { x: 0, y: 0, z: 0 },
          radius: carWheelSize,
        })
        wheelBody3.angularDamping = 0.4
        vehicle.addWheel({
          body: wheelBody3,
          position: new CANNON.Vec3(1, 0.3, axisWidth / 6),
          axis: new CANNON.Vec3(0, 0, 1),
          direction: down,
        })

        const wheelBody4 = addSphere({
          mass: wheelMass,
          wheelMaterial,
          position: { x: 0, y: 0, z: 0 },
          radius: carWheelSize,
        })
        wheelBody4.angularDamping = 0.4
        vehicle.addWheel({
          body: wheelBody4,
          position: new CANNON.Vec3(1, 0.3, -axisWidth / 6),
          axis: new CANNON.Vec3(0, 0, 1),
          direction: down,
        })

        vehicle.addToWorld(world)

        return vehicle
      }

      engine.runRenderLoop(function () {
        world.fixedStep()

        scene.render()

        // Update the debugger
        cannonDebugger.update()

        // Update the visible meshes positions
        updateMeshPositions()
      })
    </script>
  </body>
</html>
